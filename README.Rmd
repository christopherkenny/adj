---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.path = "man/figures/README-",
    out.width = "100%"
)
```

# adj <img src="man/figures/logo.svg" align="right" height="144" />

<!-- badges: start -->
[![R-CMD-check](https://github.com/alarm-redist/adj/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/alarm-redist/adj/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/alarm-redist/adj/graph/badge.svg)](https://app.codecov.io/gh/alarm-redist/adj)
<!-- badges: end -->

`adj` provides a lightweight adjacency list class for R, built on the [vctrs](https://vctrs.r-lib.org/) package.
Adjacency lists are validated on creation, automatically reindex when subsetted or indexed, and support pretty-printing.
Lists can be easily converted to a zero-index basis, which allows for easy passing of objects to low-level languages for processing.
Creation of adjacency lists from shapefiles is supported through an optional dependency on `geos`.

## Installation

You can install the development version of `adj` from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("alarm-redist/adj")
```

## Examples

`adj` comes loaded with example data for the seven bridges of KÃ¶nigsberg.

```{r}
library(adj)
data("konigsberg")

konigsberg
```

We can build an adjacency graph using the unique identifiers of each area.

```{r}
a = adj(konigsberg$bridge_to, ids = konigsberg$area, duplicates = "allow")
print(a, n = 5)
```

Alternatively, we can create an adjacency list from a list of integers.
Here, we set `duplicates = "remove"` to remove any duplicate edges.

```{r}
adj(c(2, 3, 3), c(1, 3), c(1, 1, 2), duplicates = "remove")
```

Once created, adjacency lists can be subsetted using standard R indexing, and the internal indices will be automatically updated.

```{r}
a[1:2]
rev(a)
```

Quotient graphs can be created from adjacency lists and a grouping vector.
Here, we create a quotient graph by grouping the two islands together.

```{r}
adj_quotient(a, c("island", "north", "south", "island"))
```

Finally, adjacency lists can be converted to a matrix or zero-indexed.

```{r}
as.matrix(a)

adj_zero_index(a)
```